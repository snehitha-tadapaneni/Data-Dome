---
title: "DATS 6101 - Final Project"
output: html_document
date: "`r Sys.Date()`"
author: "Name: Snehitha Tadapaneni, Sai Rachana Kandikattu, Amrutha Jayachandradhara, Wilona Nguyen, Pramod Krishnachari
"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = F, results = "markdown", message = F)
```

# Introduction

Our research focuses on performing Modelling on Google Play Store apps to uncover patterns, 
trends, and insights regarding app characteristics, user behavior, and installation patterns. We 
are trying to see how app popularity, defined as the number of installs, is impacted by the top 
five categories, last updated, app sizes, version, and other factors. 

# Smart Question

“Our research focuses on performing Modelling on Google Play Store apps to uncover patterns, trends, and insights regarding app characteristics, user behavior, and installation patterns. We are trying to see how app popularity, defined as the number of installs, is impacted by the top five categories, last updated, app sizes, version, and other factors.”

> *Specific*: The question focuses on identifying how app popularity (defined by the number of installs) is influenced by well-defined variables, including the top five app categories, last update date, app size, version, and additional characteristics such as content rating, pricing model, and user reviews. It also aims to uncover specific patterns and trends in user behavior and installation patterns.
>
> *Measurable*: The impact of each variable (categories, last update, size, version) on app popularity is quantifiable using metrics such as the number of installs, user reviews, ratings, app size in MB, frequency of updates, and category-specific rankings. This ensures that results can be expressed numerically or statistically.
>
> *Achievable*: Given the availability of historical data from the Google Play Store (e.g., datasets spanning years and including app attributes), the analysis is feasible using data analysis techniques, statistical modeling, and machine learning. Open-source libraries and tools can efficiently handle the data preprocessing and modeling.
>
> *Relevant*: The research is pertinent to app developers, marketers, and stakeholders in the mobile app ecosystem. Understanding the factors driving app installs directly addresses key industry challenges, such as improving app visibility, optimizing user engagement, and tailoring marketing strategies for success.
>
> *Time-specific*: The research will use data from a specific timeframe (e.g., 2010-2018), ensuring that insights are grounded in a defined historical context. The results could also include temporal trends to observe how factors influencing popularity have evolved over time.

# Overview
This research aims to analyze Google Play Store apps to uncover patterns, trends, and insights into how app characteristics influence popularity, defined by the number of installs. The study will involve systematic steps, including data cleaning, exploratory data analysis (EDA), modeling, and evaluation, to address the SMART research questions.

```{r required libraries, include=F}
# The package "ezids" (EZ Intro to Data Science) includes a lot of the helper functions we developed for the course. 
# Importing the necessary libraries
library(ezids)
library(dplyr)
library(ggplot2)
library(DT)
library(corrplot)
library(lubridate)
library(tidyr)
library(scales)
library(cluster)
library(knitr)
library(kableExtra)
library(reshape2)
library(randomForest)
library(e1071)
library(caret)
library(xgboost)
library(pROC)
```

# Data Preparation and Cleaning

Here, we have loaded the dataset 'Google Play Store Apps' stored in csv file using ()

```{r}
#Loading the Dataset
data_apps <- data.frame(read.csv("googleplaystore.csv"))
```

```{r}
#Checking the structure of the data
str(data_apps)
```
```{r}
#First 5 rows of the dataset
head(data_apps)
```

#### Description of the App Dataset Columns
1) App: The name of the application, represented as a character string.
2) Category: The main category of the app, such as "ART_AND_DESIGN," represented as a character string.
3) Rating: The average user rating of the app, recorded as a numeric value.
4) Reviews: The total number of user reviews for the app, shown as a character string.
5) Size: The size of the application, represented as a character string.
6) Installs: The approximate number of installations for the app, stored as a character string.
7) Type: Indicates whether the app is free or paid, represented as a character string.
8) Price: The price of the app, stored as a character string. Free apps are listed as "0," while paid apps have a dollar amount.
9) Content.Rating: The target age group for the app, represented as a character string.
10) Genres: The genre(s) of the app.
11) Last.Updated: The date of the app's last update, stored as a character string.
12) Current.Ver: The current version of the app, represented as a character string.
13) Android.Ver: The minimum Android version required to run the app, stored as a character string.


## Apps

```{r ST0}
# Checking the type of the App 
typeof(data_apps$App)
```

#### Checking for duplicated apps and removing

```{r}
#Display all the duplicated Apps
duplicate_apps <- aggregate(App ~ ., data = data_apps, FUN = length)  
duplicate_apps <- duplicate_apps[duplicate_apps$App > 1, ] 
duplicate_apps <- duplicate_apps[order(-duplicate_apps$App), ] 

#View(duplicate_apps)
#print(duplicate_apps)

print(paste("Number of duplicated Apps:",nrow(duplicate_apps)))

#Removing Na values and duplicates
data_clean <- data_apps[!is.na(data_apps$App), ] 
data_clean <- data_clean[!duplicated(data_clean$App), ] 

#(After removing the duplicates) Unique values
unique_apps <- length(unique(data_clean$App))
print(paste("Number of unique apps after removing the duplicates:", unique_apps))

```

Duplicate App Analysis:

* 404 apps were repeated either twice or thrice.
* After removing duplicates, the dataset now contains 9660 unique apps.
* Total duplicates removed: 1181 apps.

#### After dropping duplicate

```{r}
str(data_clean$App)
```

## Price

```{r ST1}
typeof(data_apps$Price)
```

#### Convertion of Price to numerical 
There is '$' present after each price of the App. Check and remove before conversion.

```{r}
#To check if there is dollar symbol present 
#data_clean$Price[]
```

```{r}
# Remove dollar symbols and convert to numeric
data_clean$Price <- as.numeric(gsub("\\$", "", data_clean$Price))
```

```{r}
#Recheck for dollar symbol
#data_clean$Price[]
```
All the dollar symbols are removed succesfully.
```{r}
# Summary statistics for price
summary(data_clean$Price)
```

From the unique_df, there is a missing value present in the Price column. Let's handle it!

#### Checking for missing values in Price

```{r}
missing_na <- is.na(data_clean$Price)    
missing_blank <- data_clean$Price == "" 

sum(missing_na)
sum(missing_blank, na.rm = TRUE)
```

```{r}
# Remove row where Price is NA or blank
data_clean <- data_clean[!is.na(data_clean$Price) & data_clean$Price != "", ]
```

Have removed one row #10473 which app does not have a category nameas it is not relevant to our analysis.

```{r}
#Recheck for missing values
summary(data_clean$Price)
```

##### Missing values removed succesfully. (Price)


## Type

```{r ST2}
#Checking the type of Type variable
table(data_clean$Type)
```
From the price column, we can see 8903 apps are free but it is misread somewhere in the Type column. So lets check!
```{r}
#Checking for Missing values
print(paste("Missing values:",sum(is.na(data_clean$Type))))

data_clean[is.na(data_clean$Type), ]

```



```{r}
# Replace NaN or missing values in the Type column with "Free"
data_clean$Type[is.na(data_clean$Type)] <- "Free"
```
There is one row 9150, has a missing value for Type. As the price is 0,
replaced it with "Free".

##### Missing values handles succesfully. (Type)


## Size

```{r}
# Checking the type of the Size 
typeof(data_apps$Size)
```
#### Replacing Misiing values with the mean (Size)
```{r}
# Replace "Varies with Device" in the Size column with NA
data_clean$Size[data_clean$Size == "Varies with device"] <- NA
data_clean <- data_clean[!grepl("\\+", data_clean$Size), ]
data_clean$Size <- ifelse(grepl("k", data_clean$Size),
                          as.numeric(gsub("k", "", data_clean$Size)) *
0.001,  # Convert "K" to MB
                          as.numeric(gsub("M", "", data_clean$Size)))
# Remove "M" for megabytes
# Calculate and display the mean size for each category in the 'Type' column
mean_size_by_type <- tapply(data_clean$Size, data_clean$Category,
mean, na.rm = TRUE)
print(mean_size_by_type)


# Loop through each row and replace NA values in the Size column with the mean size of the corresponding category
data_clean$Size <- ifelse(
  is.na(data_clean$Size),  # Check if Size is NA
  round(mean_size_by_type[data_clean$Category], 1),  # Replace with the mean size based on the Category
  data_clean$Size  # Keep the original size if it's not NA
)

```


## Installs

####Remove the '+' sign, Remove the commas, Convert to numeric

```{r A.J}
#clean installations
clean_installs <- function(Installs) {
  Installs <- gsub("\\+", "", Installs)  
  Installs <- gsub(",", "", Installs)    
  return(as.numeric(Installs))           
}

data_clean$Installs <- sapply(data_clean$Installs, clean_installs)

nan_rows <- sapply(data_clean[, c("Size", "Installs")], function(x) any(is.nan(x)))

# Display only rows that contain NaN in either Size or Installs
data_clean[,nan_rows]


datatable((data_clean), options = list(scrollX = TRUE ))
```

#### Display the unique values

```{r A.J1}
data_clean <- data_clean %>%
  mutate(Rating = ifelse(is.na(Rating), mean(Rating, na.rm = TRUE), Rating))

# Identify the unique values in the 'Installs' column
unique_values <- unique(data_clean$Installs)

# Display the unique values
print(unique_values)

# Function to convert the installs to numeric
convert_to_numeric <- function(x) {
  # Remove non-numeric characters and convert to numeric
  as.numeric(gsub("[^0-9]", "", x)) * 10^(length(gregexpr(",", x)[[1]]) - 1)
}

# Sort unique values based on the custom numeric conversion
sorted_values <- unique_values[order(sapply(unique_values, convert_to_numeric))]


```

## Rating and Reviews

```{r}
# Checking the type of the Rating 
typeof(data_clean$Rating)
```

```{r}
# Checking the type of the Reviews 
typeof(data_clean$Reviews)
```

#### Checking the format of Rating and Reviews

```{r summary statistics, echo=FALSE}
str(data_clean$Reviews)
str(data_clean$Rating)
```

As we can see the Review column is in string format which could be
converted into int for more insights.

#### Change the column reviews from Str to int

```{r , echo=FALSE}
data_clean$Reviews <- as.numeric(data_clean$Reviews)
str(data_clean)
xkablesummary(data_clean)
```

There are 1463 missing values in rating. 



As it could observed the Family category apps have the highest NA values. Let's not drop them but handle them by replacing with the mean value for the category.

```{r}
#Replace NA in Ratings with Overall Mean
data_clean <- data_clean %>%
  mutate(Rating = ifelse(is.na(Rating), mean(Rating, na.rm = TRUE), Rating))

xkablesummary(data_clean)

```

Now there are no missing values in reviews.

#### Checking for Outliers For rating by seeing frequency for each rating

```{r}
 breaks = seq(15,20,by = 1)
frequency_table = table(data_clean$Rating)
frequency_table
```

From above it can be seen all the rating are between 1 and 5.


## Category

```{r W}
# Checking the type of the Category 
typeof(data_apps$Category)
```
```{r}
length(unique(data_clean$Category))
length(unique(data_clean$Genres))
```


There are 33 categories in the the data frame with 118 genres. This means
that in each category, there are multiple genres. Given that, the later
analyses in this project can be proceeded with Category variable.

Below is the graph for the distribution of Categories for the dataset
after removing duplicates.


## Current Version & Genres

Due to the inconsistent formatting of values in the `Current.Ver`
column, this column is dropped and will be excluded from the analysis.

```{r}
data_final <- data_clean %>% select(-c('Genres', 'Current.Ver'))
data_final$Category <- factor(data_final$Category)
data_final$Android.Ver <- factor(data_final$Android.Ver)
```


## Content Rating, Last Updated

```{r}
# Remove leading and trailing spaces and convert all text to a consistent format 
data_final$Content.Rating <- trimws(tolower(data_final$Content.Rating))

cr_missing <- sum(is.na(data_final$`Content Rating`))

print(paste("Number of missing values in 'Content Rating':", cr_missing))
```
There are no missing values for Content rating.

```{r}
# Convert Last Updated to Date format
data_final$Last.Updated <- as.Date(data_final$Last.Updated, format = "%B %d, %Y")

# Verify the cleaning
print("\nSummary of Last.Updated after cleaning:")
print(summary(data_clean$Last.Updated))
```


#### After cleaning the Data
```{r}
str(data_final)
```


# Data Exploring and Visualization

#### Visualization for Price Distribution

```{r}
# Count Plot for the Price distribution
ggplot(data_final, aes(x=Price)) +
  geom_histogram(binwidth=2, fill="pink", color="black") +
   xlim(0, 500) + ylim(0, 500) +
  labs(title="Price Distribution", x="Price", y="Frequency") +
  theme_minimal()

```

The data is highly skewed as there are many zero price entries.

```{r}
# Boxplot for the same
ggplot(data_final, aes(y=Price)) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 1, fill="pink", color="black") +
  labs(title="Price Boxplot", y="Price") +
  theme_minimal()
```


#### Checking outliers for Price

```{r}
outlierKD2 <- function(df, var, rm = FALSE, boxplt = FALSE, histogram = TRUE, qqplt = FALSE) {
  dt <- df  # Duplicate the dataframe for potential alteration
  var_name <- eval(substitute(var), eval(dt))
  na1 <- sum(is.na(var_name))
  m1 <- mean(var_name, na.rm = TRUE)
  colTotal <- boxplt + histogram + qqplt  # Calculate the total number of charts to be displayed
  par(mfrow = c(2, max(2, colTotal)), oma = c(0, 0, 3, 0))  # Adjust layout for plots
  
  # Q-Q plot with custom title
  if (qqplt) {
    qqnorm(var_name, main="Q-Q plot without Outliers")
    qqline(var_name)
  }
  
  # Histogram with custom title
  if (histogram) { 
    hist(var_name,main = "Histogram without Outliers", xlab = NA, ylab = NA) 
  }
  
  # Box plot with custom title
  if (boxplt) { 
    boxplot(var_name, main= "Box Plot without Outliers")
  }
  
  # Identify outliers
  outlier <- boxplot.stats(var_name)$out
  mo <- mean(outlier)
  var_name <- ifelse(var_name %in% outlier, NA, var_name)
  
  # Q-Q plot without outliers
  if (qqplt) {
    qqnorm(var_name, main="Q-Q plot with Outliers")
    qqline(var_name)
  }
  
  # Histogram without outliers
  if (histogram) { 
    hist(var_name, main = "Histogram with Outliers", xlab = NA, ylab = NA) 
  }
  
  # Box plot without outliers
  if (boxplt) { 
    boxplot(var_name, main = "Boxplot with Outliers") 
  }
  
  # Add the title for the overall plot section if any plots are displayed
  if (colTotal > 0) {
    title("Outlier Check", outer = TRUE)
    na2 <- sum(is.na(var_name))
    cat("Outliers identified:", na2 - na1, "\n")
    cat("Proportion (%) of outliers:", round((na2 - na1) / sum(!is.na(var_name)) * 100, 1), "\n")
    cat("Mean of the outliers:", round(mo, 2), "\n")
    cat("Mean without removing outliers:", round(m1, 2), "\n")
    cat("Mean if we remove outliers:", round(mean(var_name, na.rm = TRUE), 2), "\n")
  }
}

```

```{r}
#outlier function is defined in previous chunck of code.
outlier_check_price = outlierKD2(data_final, Price, rm = FALSE, boxplt = TRUE, qqplt = TRUE)
```

The price values in the dataset, including both typical and extreme values, are valid observations for our analysis. As such, removing these outliers may not be beneficial for our study.

```{r}
#To check the value ranges
table(data_final$Price)
```
As aldready mentioned, there are 8903 free apps (More apps with price as 0).


#### Visualization for Type Distribution


```{r}
# Bar Plot for the Type Distribution
ggplot(data_final, aes(x = Type)) +
  geom_bar(fill = "pink", color = "black") +
  labs(title = "Distribution of App Types (Free vs Paid)", x = "Type", y = "Count") +
  theme_minimal()
```
As it is clear, there are more free apps.

```{r}
#Display statistics for the Price of apps grouped by their Type
data_final$Type <- as.factor(data_final$Type)


summary_by_type <- data.frame(
  Type = levels(data_final$Type),
  Min_Price = tapply(data_clean$Price, data_clean$Type, min, na.rm = TRUE),
  Max_Price = tapply(data_clean$Price, data_clean$Type, max, na.rm = TRUE),
  Mean_Price = tapply(data_clean$Price, data_clean$Type, mean, na.rm = TRUE),
  Median_Price = tapply(data_clean$Price, data_clean$Type, median, na.rm = TRUE)
)


print(summary_by_type)
```

```{r}
#Scatter plot for price distribution by app type
ggplot(data_final, aes(x = Type, y = Price, fill = Type)) +
  geom_boxplot() +
  labs(title = "Price Distribution by App Type", 
       x = "App Type", 
       y = "Price ($)") +
  theme_minimal()
```

#### Histogram for price distribution by App Type

```{r}
ggplot(data_final, aes(x = Price, fill = Type)) +
  geom_histogram(binwidth = 60, alpha = 0.7, position = "identity") +
  facet_wrap(~ Type) +
  labs(title = "Price Distribution by App Type", 
       x = "Price ($)", 
       y = "Count") +
  theme_minimal()
```

Upon analyzing the price distribution across different app types, we found that some values in the Type column do not accurately represent the app prices (from above plot). Since we can fully rely on the Price values for our analysis, the Type column is seemed unnecessary.

Hence, Removing the Type column...

#### Dropping the Type column
```{r}
#Using subset function
data_final <- subset(data_final, select = -Type)
```

```{r}
#After removing the Type column and duplicated values
str(data_final)
```

##### The Type column is successfully removed.

Let's do bivariate analysis on price and other variables starting from here.

#### Visualization for Price vs Installs 

```{r ST3}
#Plotting a scatter plot between Price and installs
ggplot(data_final, aes(x=Price, y=log(data_clean$Installs))) +
  geom_point(color = 'red', size = 1, alpha = 0.5) + 
  geom_smooth(method = 'lm', color = 'blue', se = FALSE) +
  labs(title = "Price vs Installs", x = "Price (USD)", y = "Number of Installs") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
From the scatter plot, we can see that there are more number of installations with price value 0. 

```{r}
# Categorize the apps as "Free" or "Paid" based on Price
Price_Category <- ifelse(data_final$Price == 0, "Free", "Paid")
str(data_final$Price)
str(Price_Category)
#str(log(data_clean$Installs))

```
For a better visualization, we are categorizing price values 0 as free apps and plotting abox plot. 
```{r}
# Box plot of Price Category vs. log-transformed Installs
ggplot(data_final, aes(x = Price_Category, y = log(data_clean$Installs))) +
  geom_boxplot(fill = "lightblue", color = "darkblue", alpha = 0.6) +
  labs(title = "Price Categories vs. Log-Transformed Installs", 
       x = "Price Category", 
       y = "Log(Installs)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  
```

"Free" apps tend to have more installs than "Paid" apps. The difference between the means on the log scale is estimated to be between 3.47 and
3.97.

```{r}
# Categorize the apps as "Free" or "Paid" based on Price
Price_Category <- ifelse(data_final$Price == 0, "Free", "Paid")
str(data_final$Price)
str(Price_Category)
#str(data_final$log(data_clean$Installs))

table(Price_Category)

```

```{r}
# Add Price_Category to data_final
data_duplicate <- data_final
data_duplicate$Price_Category <- ifelse(data_final$Price == 0, "Free", "Paid")

# Create a summarized table for Price_Category and log_Installs
summary_table <- data_duplicate %>%
  group_by(Price_Category) %>%
  summarise(Average_Log_Installs = mean(log(data_clean$Installs), na.rm = TRUE),
            Count = n())

# View the summarized table
kable(summary_table, format = "html", col.names = c("Price Category", "Mean Log(Installs)", "App Count")) %>%
  kable_styling(full_width = FALSE, position = "center") 

```

#### Visualization for Price vs Reviews & Rating

```{r}
# Plot Price vs. Reviews
ggplot(data_final, aes(x=Price, y=Reviews)) +
  geom_point(color = 'blue') +
  geom_smooth(method = 'lm', color = 'red', se = FALSE) +
  labs(title = "Price vs Reviews", x = "Price (USD)", y = "Number of Reviews") +
  theme_minimal() + 
  theme(
    panel.background = element_rect(fill = "white"),  # Set panel background to white
    plot.background = element_rect(fill = "white"),   # Set plot background to white
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# Plot Price vs. Rating
ggplot(data_final, aes(x=Price, y=Rating)) +
  geom_point(color = 'green') +
  geom_smooth(method = 'lm', color = 'red', se = FALSE) +
  labs(title = "Price vs Rating", x = "Price (USD)", y = "Rating") +
  theme_minimal() + 
  theme(
    panel.background = element_rect(fill = "white"),  # Set panel background to white
    plot.background = element_rect(fill = "white"),   # Set plot background to white
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

Price vs Reviews with installation: Cheaper products tend to have more
reviews, indicating higher popularity or more frequent purchases. In
contrast, expensive products tend to have fewer reviews, possibly
because fewer people buy higher-priced items.

Price vs Ratings with installation: Price does not strongly affect the
average rating, but there is a slight trend where lower-priced products
have more variation in ratings, while higher-priced products tend to
receive more consistent ratings around 4. May be higher price apps are
meeting the customer expectations.

 
#### Visualization for Price vs Reviews vs Installs

```{r}
# Scatter plot of Price vs. Ratings with log_Installs as  color
ggplot(data_final, aes(x = Price, y = Rating,color = log(data_clean$Installs))) +
  geom_point(alpha = 0.6) +
  scale_color_gradient(low = "blue", high = "red") +  
  labs(title = "Price vs. Ratings with Installs as Color by Price", 
       x = "Price", 
       y = "Rating", 
       color = "log(Installs)") +
  theme_minimal()

# Scatter plot of Price vs. Reviews with log_Installs as color
ggplot(data_final, aes(x = Price, y = Reviews,color = log(data_clean$Installs))) +
  geom_point(alpha = 0.6) +
  scale_color_gradient(low = "darkgreen", high = "yellow") +  
  labs(title = "Price vs. reviewss with Installs as Color by Price", 
       x = "Price", 
       y = "Reviews", 
       color = "log(Installs)") +
  theme_minimal()
```

Concluding: Apps with lower prices, have more ratings and installs while
apps priced higher tend to have fewer installs and more scattered
ratings. Similarly, for reviews.

#### Visualization for Price vs Size 

```{r}
# Plot Price vs Size
ggplot(data_final, aes(x=Price, y=Size)) +
  geom_point(color = 'red') + 
  geom_smooth(method = 'lm', color = 'blue', se = FALSE) +
  labs(title = "Price vs Size", x = "Price (USD)", y = "App Size (MB)") +
  theme_minimal() 
```


#### Visulization for Distribution of Installs

```{r }
# Create a new data frame to store the factor levels
data_clean1_factor <- data_final  # Assuming you want to keep the original data intact
data_clean1_factor$Installs <- factor(data_final$Installs, levels = sorted_values)
# Define new breaks for more even intervals for Installs
install_breaks <- c(c(0, 500, 1000, 5000, 10000, 50000, 100000, 300000, 1000000, 5000000,10000000, Inf))

# Create a categorical variable for installs based on these breaks
data_clean1_factor$Installs_Category <- cut(
  as.numeric(as.character(data_final$Installs)), 
  breaks = install_breaks, 
  right = FALSE, 
  labels = c("0+", "500+", "1K+", "5K+", "10K+", "50K+", "100K+", "300K+", "1M+", "5M+","Above 10M+")
)


# Plot the categorized Installs data
library(ggplot2)
ggplot(data_clean1_factor, aes(x = Installs_Category)) +
  geom_bar() +
  xlab("Installs") +
  ylab("Count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Distribution of App Installs by Category")

```
#### Installs vs Size
```{r}
ggplot(data_clean, aes(x = Size, y = log(Installs))) +
  geom_hex(bins = 30) +
  scale_fill_viridis_c() + # Adds color gradient
  labs(title = "Plot of App Size vs. Installs (Log Scale)",
       x = "Size (MB)",
       y = "Installs (Log Scale)") +
  theme_minimal()
```

### Visualization for Rating Distribution

```{r}
boxplot(data_final$Rating,ylab = "Rating", xlab = "Count",col = "Blue")
hist(data_clean$Rating, main="Histogram of Apps Rating after cleaning", xlab="Rating (count)", col = 'blue', breaks = 100 )
qqnorm(data_clean$Rating)
qqline(data_clean$Rating, col = "red")
```

Here, it could be seen the plots are much clearer but still skewed due
to other outliers from 1-3 rating but as these may be the reason from
which we could find why the apps are low rated hencecannot be removed
from our dataset.

### Visualization for Reviews

```{r}

boxplot(data_final$Reviews,ylab = "Reviews", xlab = "Count",col = 'Blue')
hist(data_final$Reviews, main="Histogram of Apps Reviews", xlab="Reviews (count)", col = 'blue', breaks = 100 )
ggplot(data_final, aes(x = log(Reviews))) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black") +
  labs(title = "Log-Transformed Histogram of Ratings", x = "Log(Rating)", y = "Count")

qqnorm(data_final$Reviews)
qqline(data_final$Reviews, col = "red")

```

Similar to the case of ratings the plots are skewed due to the outliers.
Hence, we can use the log plot of reviews for the visualisation which is
normalised version of Reviews. As they are skewed, they donot follow
normal distribution.

#### Review frequency table

```{r}
xkablesummary(data_final)
outlierKD2(data_final, Reviews)
```

To check which are outliers lets make sections of data that is create
bins to check which bins have maximum data, this would help us see how
reviews are distributed.

#### Binned reviews

Binning into equal count in each bin to check averge rating for each bin

```{r}
# Define the new custom breaks for bins
# Ensure there are no NA values


# Define new breaks for more even intervals
breaks <- c(0, 100, 500, 1000, 2500, 5000, 10000, 25000,50000,100000, 300000,1000000,Inf)

# Create a categorical variable based on the new breaks
Review_Category <- cut(data_final$Reviews, breaks = breaks, right = FALSE, 
                   labels = c("0+","100+", "500+", "1K+",
                              "2.5K+", "5K+", "10K+","25K+",
                              "50K+", "100K+","300K+","1M+"))

# Count the number of values in each bin
bin_counts <- as.data.frame(table(Review_Category))

# Rename the columns for clarity
colnames(bin_counts) <- c("Review_Category", "Count")

# Print the counts
print(bin_counts)

# Create a line plot of the binned counts
ggplot(bin_counts, aes(x = Review_Category, y = Count, group = 1)) +
  geom_line(color = "blue", size = 1) +
  geom_point(color = "blue", size = 3) +
  labs(title = "Count of Reviews by Review Category", 
       x = "Review Category", 
       y = "Count of Reviews") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for readability
```

Hence, high reviews can be observed in less apps and less reviews can be
observed in more apps which is expected.

#### Boxplots for Rating vs Reviews

```{r}
boxplot( data_final$Rating~ Review_Category, data = data_clean, 
        main = "Boxplot of Review Counts by Review Category", 
        xlab = "Review Category", 
        ylab = "Review Rating",
        las = 2,        # Rotate the x-axis labels for readability
        col = "lightblue")  # Optional: Set color for the boxplots

```

In this we could observe that, as reviews increase the median of rating
increased and the values clustered around higher ratings which could
show that high reviews, could mean a better rated app.

#### Mean value of Ratings for each Review bins

```{r}

# Calculate the mean Rating for each Review_Category
mean_ratings <- tapply(data_final$Rating, Review_Category, mean, na.rm = TRUE)

# Convert the result to a data frame for better readability
mean_ratings_df <- data.frame(Review_Category = names(mean_ratings), Mean_Rating = as.numeric(mean_ratings))

# Print the mean ratings for each review bin
print(mean_ratings_df)

# Define correct order of Review_Category as a factor
mean_ratings_df$Review_Category <- factor(mean_ratings_df$Review_Category, 
                                          levels = c("0+","100+", "500+", "1K+",
                                                     "2.5K+", "5K+", "10K+","25K+",
                                                     "50K+", "100K+", "300K+", "1M+"))

# Plot the mean ratings for each review bin in the correct order
ggplot(mean_ratings_df, aes(x = Review_Category, y = Mean_Rating)) +
  geom_bar(stat = "identity", fill = "steelblue") +  # Use bar plot
  labs(title = "Mean Rating by Review Category",
       x = "Review Category",
       y = "Mean Rating") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for readability



```

As we can see, the mean rating increases as the reviews increase.

#### Histogram for Reviews and Rating

```{r}
# Create a new data frame for plotting
plot_data <- data.frame(Rating = data_final$Rating, Review_Category = Review_Category)

# Create a histogram of Ratings, faceted by Review_Category
ggplot(plot_data, aes(x = Rating)) +
  geom_histogram(bins = 30, fill = "blue", alpha = 0.7) +
  facet_wrap(~ Review_Category, labeller = label_wrap_gen()) +  # Facet by Review_Category
  theme_minimal() +
  labs(title = "Histograms of Ratings by Review Category", x = "Rating", y = "Frequency")
```

This is another representation of ratings vs reviews.

#### Visualization for Reviews vs Installs

```{r A.J3}

# Scatter plot for Installs vs Reviews
ggplot(data_clean1_factor, aes(x = Reviews, y = Installs)) +
  geom_point(color = "blue", alpha = 0.5) +
  labs(title = "Scatter Plot of Installs vs Reviews", 
       x = "Number of Reviews", 
       y = "Number of Installs") +
  theme_minimal()

```

#### Visualization for Rating vs Installs
```{r A.J4}
# Scatter plot of log-transformed Installs vs. Rating
ggplot(data_final, aes(x = log(data_clean$Installs), y = Rating)) +
  geom_point(color = "blue", alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = FALSE) +  # Add a regression line
  labs(title = "Log-Transformed Installs vs. Rating", 
       x = "Log(Installs)", 
       y = "Rating") +
  theme_minimal()

```

#### Visualization for Rating vs Installs by Category

```{r A.J5, echo=FALSE, fig.width=12, fig.height=8, out.width='100%', fig.align='center'}

# Plot the combined graph with different colors based on Rating
ggplot(data_final, aes(x = log(data_clean$Installs), y = Rating)) +
  geom_point(aes(color = as.factor(Rating), shape = Category), alpha = 0.6, size = 3) +  # Points colored by Rating and shaped by Category
  scale_color_discrete(name = "Rating") +  # Discrete color scale
  labs(title = "Rating vs Installs (Log-Transformed Installs) by Category",
       x = "Log of Installs", y = "Rating") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  guides(shape = guide_legend(title = "Category"))  # Add legend title for Category

```

#### Visualization for Category Distribution

```{r}
category_counts <- table(data_final$Category)

# Convert to data frame for plotting
category_counts_df <- as.data.frame(category_counts)
colnames(category_counts_df) <- c("Category", "Frequency") 

ggplot(category_counts_df, aes(x = reorder(Category, Frequency), y = Frequency)) + 
  geom_bar(stat = "identity", fill = "#1f3374") +
  geom_text(aes(label = Frequency), vjust = 0.5, hjust=1, size=2.5, color='#f8c220') +
  coord_flip() +  
  labs(title = "Distribution of Categories", x = "Category", y = "Frequency") +
  theme_minimal() +
   theme(
    plot.background = element_rect(fill = "#efefef", color = NA),
    panel.background = element_rect(fill = "#efefef", color = NA),
    axis.text.y = element_text(size = 5.5)
  )
```

AS it can be seen from the graph above, most of the apps in the dataset belong to the Family category, and Beauty has the least number of apps. 

#### Visualization for Category vs. Installs

Below is a boxplot show the distribution of number of installs for each
category order by mean from highest to lowest. 

```{r}
ggplot(data_clean, aes(x = reorder(Category, log(data_final$Installs),  FUN = mean), y = log(data_clean$Installs))) +
  geom_boxplot(outlier.color = "#f05555", outlier.shape = 1, color='#1f3374', fill="#efefef") +  # Red outliers for emphasis
  coord_flip() +  # Flip for better readability
  scale_y_log10() +
  theme_minimal() +
  labs(title = "Distribution of Installs by Category",
       x = "Category",
       y = "Number of Installs (Log Scale)") +
    theme(
    plot.background = element_rect(fill = "#efefef", color = NA),
    panel.background = element_rect(fill = "#efefef", color = NA),
    axis.text.y = element_text(size = 5.5)
  )
```
It can be seen from the graph that, on average, Entertainment apps receive the highest number of installations, followed by Education, Game, Photography, and Weather apps. In contrast, Art & Design apps have the fewest installations.

#### Visualization for Category vs. App Size

Below is the figure showing the distribution of app sizes in each category. 

```{r}
#df_clean <- data_clean %>%
 # mutate(Size = sapply(Size, convert_size)) %>%
#  filter(!is.na(Size))

# Plot the histogram with faceting by category
ggplot(data_clean, aes(x = Size)) +
  geom_histogram(binwidth = 5, fill = "#304ba6", color = "black") +
  facet_wrap(~ Category, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Distribution of App Sizes by Category",
    x = "Size (MB)",
    y = "Count"
  ) +
  theme(
    strip.text = element_text(size = 5),
    axis.text.x = element_text(size = 7, angle = 45, hjust = 1)
  )

str(data_clean)

```


```{r}
ggplot(data_clean, aes(x = reorder(Category, Size, FUN = median), y = Size)) + 
  geom_boxplot(outlier.color = "#f05555", outlier.shape = 1) + 
  coord_flip() + 
  theme_minimal() + 
  labs(
    title = "Boxplot of App Sizes by Category (Ordered by Median)", 
    x = "Category", 
    y = "Size (MB)"
  ) + 
  theme(
    strip.text = element_text(size = 8), 
    axis.text.x = element_text(size = 7, angle = 45, hjust = 1)
  )

```

As it can be seen from the two figures above, most categories exhibit right-skewed app sizes, with the majority being under 50MB. However, the Game category stands out with a significantly larger median app size compared to other categories.

#### Visualization for Category vs. Reviews

Below is the graph displaying the distribution of reviews left by users for each category.

```{r}

df_aggregated <- data_final %>% 
  group_by(Category) %>% 
  summarise(Total_Reviews = sum(Reviews, na.rm = TRUE))

#df_aggregated

```

```{r}
# Plot the total reviews by category using a bar chart
ggplot(df_aggregated, aes(x = reorder(Category, -Total_Reviews), y = log10(Total_Reviews))) + 
  geom_bar(stat = "identity", fill = "#1f3374") + 
  labs(
    title = "Log-Scaled Total Reviews by Category", 
    x = "Category", 
    y = "Log10(Total Number of Reviews)"
  ) + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```
AS it can be seen that game apps have most reviews while events apps have the least reviews.

#### Histogram for Category vs. Rating

Below is the figure demonstrating the distribution of number of rating for each category. 

```{r}
ggplot(data_final, aes(x = Rating)) + 
  geom_histogram(binwidth = 0.5, fill = "#1f3374", color='#efefef') + 
  facet_wrap(~ Category, scales = "free_y") +  # Facet by Category with independent y-axis
  scale_x_continuous(limits = c(1, 5), breaks = seq(1, 5, by = 0.5)) +  # Restrict x-axis to 1-5
  theme_minimal() + 
  labs(
    title = "Distribution of Ratings by Category", 
    x = "Rating", 
    y = "Count"
  ) + 
  theme(
    strip.text = element_text(size = 5),  # Adjust facet label size
    axis.text.x = element_text(size = 5, angle = 45, hjust = 1),  # Rotate x-axis labels
    plot.title = element_text(hjust = 0.5)  # Center the plot title
  )



```
As illustrated in the graph above, all categories have app ratings that range between 4.0 and 5.0.


#### Visualization for Android Version

Below is the figure showing the distribution of Android versions.

```{r}
df_clean <- data_final %>% 
  filter(!is.na(Android.Ver) & !is.na(Reviews) & !(Android.Ver == 'NaN'))
```


```{r}
extract_version <- function(version) {
  version <- tolower(version)  # Make lowercase for consistency
  
  # Handle "Varies with device" and "NaN"
  if (version == "varies with device" || version == "nan") return(NA)
  
  # Extract the first version in case of ranges (e.g., "4.1 - 7.1.1" -> "4.1")
  first_version <- strsplit(version, "[- ]")[[1]][1]
  
  # Remove "and up" if present (e.g., "4.0 and up" -> "4.0")
  first_version <- gsub("and up", "", first_version)
  
  return(as.numeric(first_version))  # Convert to numeric
}



```

```{r}
df_clean <- data_final %>%
  mutate(Android_Ver = sapply(Android.Ver, extract_version)) %>%
  filter(!is.na(Android_Ver))  # Remove rows with NA in Android_Ver

android_installs <- data_final %>% 
  group_by(Android.Ver) %>% 
  summarize(Total_Installs = sum(Installs, na.rm = TRUE))


```

```{r}
ggplot(df_clean, aes(x = Android_Ver)) + 
  geom_histogram(binwidth = 0.5, fill = "#1f3374", color='#efefef') + 
  scale_x_continuous(breaks = seq(1, 8, by = 1.0)) +  # Set x-axis ticks from 1.0 to 8.0
  theme_minimal() + 
  labs(
    title = "Distribution of Android Versions", 
    x = "Android Version", 
    y = "Count"
  ) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
As it can be seen that, the minimum required Android Version for most apps is 4.0 and up. 

```{r}
extract_version <- function(version) {
  version <- tolower(version)  # Make lowercase for consistency
  
  # Handle "Varies with device" and "NaN"
  if (version == "varies with device" || version == "nan") return(NA)
  
  # Extract the first version in case of ranges (e.g., "4.1 - 7.1.1" -> "4.1")
  first_version <- strsplit(version, "[- ]")[[1]][1]
  
  # Remove "and up" if present (e.g., "4.0 and up" -> "4.0")
  first_version <- gsub("and up", "", first_version)
  
  return(as.numeric(first_version))  # Convert to numeric
}

```

#### Bar plot for Android Version vs. Installs

Below is the graph showing the number of installs for each minimum required Android Version. 

```{r}
ggplot(df_clean, aes(x = reorder(Android.Ver, Installs), y = Installs)) + 
  geom_bar(stat = "identity", fill = "#1f3374") + 
  coord_flip() +  # Flip coordinates for better readability
  scale_y_continuous(labels = scales::comma) +  # Format y-axis with commas
  theme_minimal() + 
  labs(
    title = "Total Installs by Android Version", 
    x = "Android Version", 
    y = "Total Installs"
  ) + 
  theme(
    axis.text.y = element_text(size = 8),  # Adjust y-axis text size
    plot.title = element_text(hjust = 0.5)  # Center the plot title
  )

```

It can be seen that the highest number of installation is when there is different requirements of the versions for the app to run. 

#### Boxplot for Android Version vs. Reviews

Below is the distribution of reviews for each minimum required Android Version.

```{r}
df_clean <- data_final %>% 
  filter(!is.na(Android.Ver) & !is.na(Reviews) & !(Android.Ver == 'NaN')) %>% 
  mutate(Scaled_Reviews = log10(Reviews + 1))
```

```{r}
ggplot(df_clean, aes(x = reorder(Android.Ver, Scaled_Reviews, FUN = median), y = Scaled_Reviews)) + 
  geom_boxplot(outlier.color = "#f05555", outlier.shape = 1) +  # Boxplot with red outliers
  coord_flip() +  # Flip coordinates for better readability
  theme_minimal() + 
  labs(
    title = "Distribution of Scaled Reviews by Android Version", 
    x = "Android Version", 
    y = "Scaled Reviews (Log10)"
  ) + 
  theme(
    axis.text.y = element_text(size = 8),  # Adjust y-axis text size
    plot.title = element_text(hjust = 0.5)  # Center the plot title
  )

```

It can be seen that the version from 4.1 to 7.1.1 have the highest number of reviews, whiel version from 5.0 to 7.1.1 have the least number of reviews. 


####  Histogram for Android Version vs. Rating

Below is the plot showing the number of ratings for each Android Version. 

```{r}
ggplot(df_clean, aes(x = Rating, fill = Android.Ver)) + 
  geom_histogram(binwidth = 0.5, position = "stack", color = "black", alpha = 0.7) + 
  scale_x_continuous(breaks = seq(1, 5, by = 0.5)) +  # Set x-axis breaks
  theme_minimal() + 
  labs(
    title = "Histogram of Ratings by Android Version", 
    x = "Rating", 
    y = "Count"
  ) + 
  theme(
    axis.text.x = element_text(size = 8), 
    axis.text.y = element_text(size = 8), 
    plot.title = element_text(hjust = 0.5)  # Center the plot title
  )

```
It can be seen that most Android Version have ratings range between 4.0 and 5.0.


#### Distribution for Content.Rating

```{r}
# Clean and prepare the Last Updated  and Content column
data_updated <- data_final %>%
  mutate(
    Content.Rating = as.factor(Content.Rating)
  )

# 1. Content Rating Distribution
content_rating_dist <- table(data_updated$Content.Rating)
print("Content Rating Distribution:")
print(content_rating_dist)
```

#### Visualization for Content Rating

```{r}
# Bar plot for Content Rating
ggplot(data_final, aes(x = Content.Rating)) +
  geom_bar(fill = "skyblue") +
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5) +
  labs(title = "Distribution of App Content Ratings",
       x = "Content Rating",
       y = "Number of Apps") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
Everyone is the most dominant Category with 81.82% of all apps and Adults 18+ being most least significant category with about 0.03% of overall app population


```{r}
# Last Updated Analysis
# Create summary of updates by month and year
updates_by_month <- data_updated %>%
  mutate(
    update_month = format(Last.Updated, "%Y-%m"),
    update_year = year(Last.Updated)
  ) %>%
  group_by(update_month) %>%
  summarize(count = n()) %>%
  arrange(update_month)
```

```{r}
# Plot updates over time
#ggplot(updates_by_month, aes(x = as.Date(paste0(update_month, "-01")), y = count)) +
  #geom_line(color = "blue") +
  #geom_point(color = "red") +
  #labs(title = "Number of App Updates Over Time",
  #     x = "Date",
  #     y = "Number of Updates") +
  #theme_minimal() +
 # theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# Content Rating and Update Frequency Relationship
update_frequency_by_rating <- data_updated %>%
  group_by(Content.Rating) %>%
  summarize(
    avg_last_update = mean(Last.Updated),
    median_last_update = median(Last.Updated),
    n_apps = n()
  )
print("\nUpdate Frequency by Content Rating:")
print(update_frequency_by_rating)
```

```{r}
# Basic statistics for Installs by Content Rating
installs_by_rating <- data_updated %>%
  group_by(Content.Rating) %>%
  summarise(
    mean_installs = mean(Installs, na.rm = TRUE),
    median_installs = median(Installs, na.rm = TRUE),
    total_installs = sum(Installs, na.rm = TRUE),
    n_apps = n()
  ) %>%
  arrange(desc(mean_installs))

print("Summary of Installs by Content Rating:")
print(installs_by_rating)

# Basic statistics for Ratings by Content Rating
ratings_by_content <- data_updated %>%
  group_by(Content.Rating) %>%
  summarise(
    mean_rating = mean(Rating, na.rm = TRUE),
    median_rating = median(Rating, na.rm = TRUE),
    total_ratings = sum(Rating, na.rm = TRUE),
    n_apps = n()
  ) %>%
  arrange(desc(mean_rating))

print("Summary of Ratings by Content Rating:")
print(ratings_by_content)

# Basic statistics for Reviews by Content Rating
reviews_by_content <- data_updated %>%
  group_by(Content.Rating) %>%
  summarise(
    mean_reviews = mean(Reviews, na.rm = TRUE),
    median_reviews = median(Reviews, na.rm = TRUE),
    total_reviews = sum(Reviews, na.rm = TRUE),
    n_apps = n()
  ) %>%
  arrange(desc(mean_reviews))

print("Summary of Reviews by Content Rating:")
print(reviews_by_content)

```

```{r}
# Create days_since_update and data preparation
data_updated <- data_final %>%
  mutate(
    # Convert Last.Updated to proper date format (assuming it's in standard format)
    last_updated = as.Date(Last.Updated),
    current_date = Sys.Date(),
    # Calculate days since last update
    days_since_update = as.numeric(difftime(current_date, last_updated, units = "days")),
    # Extract month from last_updated date
    update_month = month(last_updated)
  ) %>%
  # Remove any invalid dates or NA values
  filter(!is.na(last_updated), !is.na(days_since_update))

# Create subset for update analysis
data_updated <- data_updated %>% filter(!is.na(days_since_update))

# Calculate update statistics by Content Rating
update_patterns <- data_updated %>%
  group_by(Content.Rating) %>%
  summarize(
    avg_days_since_update = mean(days_since_update, na.rm = TRUE),
    median_days_since_update = median(days_since_update, na.rm = TRUE),
    sd_days_since_update = sd(days_since_update, na.rm = TRUE),
    n_apps = n(),
    cv = sd_days_since_update / avg_days_since_update * 100  # Coefficient of Variation
  ) %>%
  arrange(avg_days_since_update)

print("\nUpdate Patterns by Content Rating:")
print(update_patterns)

# Create monthly update counts
update_heatmap_data <- data_updated %>%
  group_by(update_month, Content.Rating) %>%
  summarize(count = n(), .groups = 'drop') %>%
  # Ensure all months and ratings are included, even if count is 0
  complete(
    update_month = 1:12,
    Content.Rating = unique(data_updated$Content.Rating),
    fill = list(count = 0)
  ) %>%
  # Reshape data for heatmap
  pivot_wider(
    names_from = Content.Rating,
    values_from = count
  )

# Convert to matrix for traditional heatmap
update_matrix <- as.matrix(update_heatmap_data[,-1])
rownames(update_matrix) <- month.abb[update_heatmap_data$update_month]

# Create enhanced heatmap using ggplot2
heatmap_data_long <- melt(update_matrix)
colnames(heatmap_data_long) <- c("Month", "Content_Rating", "Count")
heatmap_data_long$Month <- factor(heatmap_data_long$Month, levels = month.abb)

# Create the heatmap visualization
ggplot(heatmap_data_long, aes(x = Content_Rating, y = Month, fill = Count)) +
  geom_tile(color = "white") +  # Add white borders between tiles
  scale_fill_gradient(
    low = "white", 
    high = "steelblue", 
    name = "Number of Updates"
  ) +
  theme_minimal() +
  labs(
    title = "App Update Patterns by Content Rating",
    x = "Content Rating",
    y = "Month",
    subtitle = paste("Data as of", format(Sys.Date(), "%B %d, %Y"))
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid = element_blank(),
    panel.border = element_rect(fill = NA, color = "grey80"),
    legend.position = "right"
  )

# Calculate update velocity
update_velocity <- data_updated %>%
  group_by(Content.Rating) %>%
  summarize(
    update_velocity = n() / n_distinct(update_month),
    total_apps = n(),
    avg_days_between_updates = mean(days_since_update, na.rm = TRUE)
  ) %>%
  arrange(desc(update_velocity))

print("\nUpdate Velocity by Content Rating:")
print(update_velocity)

# Optional: Additional summary statistics for days since update
summary_stats <- data_updated %>%
  summarize(
    mean_days = mean(days_since_update, na.rm = TRUE),
    median_days = median(days_since_update, na.rm = TRUE),
    min_days = min(days_since_update, na.rm = TRUE),
    max_days = max(days_since_update, na.rm = TRUE),
    q1_days = quantile(days_since_update, 0.25, na.rm = TRUE),
    q3_days = quantile(days_since_update, 0.75, na.rm = TRUE)
  )

print("\nOverall Summary Statistics for Days Since Update:")
print(summary_stats)
```

##### Observation for Update Frequency Velocity Analysis:
This column represents the average number of updates per app for each content rating category. It reflects how frequently apps in each category receive updates.

```{r}
# # 1. Update Cycle Analysis
# data_updated <- data_updated %>%
#   mutate(
#     Last.Updated = as.Date(Last.Updated, format = "%B %d, %Y"),
#     day_of_week = wday(Last.Updated, label = TRUE),
#     week_of_year = week(Last.Updated),
#     month_of_year = month(Last.Updated, label = TRUE),
#     season = case_when(
#       month_of_year %in% c("Dec", "Jan", "Feb") ~ "Winter",
#       month_of_year %in% c("Mar", "Apr", "May") ~ "Spring",
#       month_of_year %in% c("Jun", "Jul", "Aug") ~ "Summer",
#       TRUE ~ "Fall"
#     )
#   )
# 
# # Day of Week Update Pattern by Content Rating
# dow_pattern <- data_updated %>%
#   group_by(Content.Rating, day_of_week) %>%
#   summarise(count = n()) %>%
#   group_by(Content.Rating) %>%
#   mutate(percentage = count/sum(count) * 100)
# 
# ggplot(dow_pattern, aes(x = day_of_week, y = percentage, fill = Content.Rating)) +
#   geom_bar(stat = "identity", position = "dodge") +
#   facet_wrap(~Content.Rating) +
#   labs(title = "Update Day Preferences by Content Rating",
#        x = "Day of Week",
#        y = "Percentage of Updates") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# Update Interval Analysis
update_intervals <- data_updated %>%
  group_by(Content.Rating) %>%
  arrange(Last.Updated) %>%
  mutate(days_between_updates = as.numeric(Last.Updated - lag(Last.Updated))) %>%
  summarise(
    mean_interval = mean(days_between_updates, na.rm = TRUE),
    median_interval = median(days_between_updates, na.rm = TRUE),
    std_dev = sd(days_between_updates, na.rm = TRUE),
    cv = std_dev / mean_interval * 100  # Coefficient of Variation
  )

print("Update Interval Analysis:")
print(update_intervals)
```


```{r}

# Create data_updated with seasonal information while keeping data_final unchanged
data_updated <- data_final %>%
  mutate(
    last_updated = as.Date(Last.Updated),
    current_date = Sys.Date(),
    days_since_update = as.numeric(difftime(current_date, last_updated, units = "days")),
    update_month = month(last_updated),
    season = case_when(
      update_month %in% c(12, 1, 2) ~ "Winter",
      update_month %in% c(3, 4, 5) ~ "Spring",
      update_month %in% c(6, 7, 8) ~ "Summer",
      update_month %in% c(9, 10, 11) ~ "Fall"
    )
  ) %>%
  filter(!is.na(last_updated), !is.na(days_since_update))

# Calculate seasonal update intensity
seasonal_intensity <- data_updated %>%
  group_by(Content.Rating, season) %>%
  summarise(
    update_count = n(),
    update_intensity = n() / n_distinct(last_updated),
    avg_days_between_updates = mean(days_since_update, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  mutate(season = factor(season, levels = c("Winter", "Spring", "Summer", "Fall"))) %>%
  arrange(Content.Rating, desc(update_intensity))

# Create enhanced seasonal bar plot
seasonal_plot <- ggplot(seasonal_intensity, 
       aes(x = season, y = update_intensity, fill = Content.Rating)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.8) +
  scale_fill_brewer(palette = "Set3") +
  labs(
    title = "Seasonal Update Intensity by Content Rating",
    subtitle = paste("Analysis Period:", format(min(data_updated$last_updated), "%B %Y"), 
                    "to", format(max(data_updated$last_updated), "%B %Y")),
    x = "Season",
    y = "Update Intensity",
    fill = "Content Rating"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    axis.text.x = element_text(angle = 0),
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "right"
  )

# Create seasonal heatmap
seasonal_heatmap <- ggplot(seasonal_intensity, 
       aes(x = season, y = Content.Rating, fill = update_intensity)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low = "white",
    high = "steelblue",
    name = "Update\nIntensity"
  ) +
  labs(
    title = "Seasonal Update Patterns Heatmap",
    x = "Season",
    y = "Content Rating"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 0),
    panel.grid = element_blank(),
    legend.position = "right"
  )

# Print both plots side by side
library(gridExtra)
grid.arrange(seasonal_plot, seasonal_heatmap, ncol = 2)

# Print seasonal statistics
print("\nSeasonal Update Intensity Statistics:")
print(seasonal_intensity)

# Additional seasonal summary
seasonal_summary <- data_updated %>%
  group_by(season) %>%
  summarise(
    total_updates = n(),
    avg_days_since_update = mean(days_since_update, na.rm = TRUE),
    median_days_since_update = median(days_since_update, na.rm = TRUE),
    n_apps = n_distinct(Content.Rating),
    .groups = 'drop'
  ) %>%
  arrange(match(season, c("Winter", "Spring", "Summer", "Fall")))

print("\nOverall Seasonal Summary:")
print(seasonal_summary)

```
The visualization shows the seasonal update intensity for various content ratings across different seasons (Fall, Spring, Summer, and Winter). The "Update Intensity" measures how frequently updates occurred, normalized by the number of distinct update events. The graph reveals that content rated as "everyone" consistently exhibits higher update intensity across all seasons, particularly peaking during the Summer. Other content ratings, such as "mature 17+" and "teen," show notable but lower intensities, with a generally even distribution across seasons. This pattern suggests that applications rated for general audiences tend to undergo more frequent updates, especially during the Summer, potentially to meet increased demand or prepare for seasonal trends.


#### Visualization for Content Rating vs Installs

```{r}

installs_by_rating <- data_updated %>%
  group_by(Content.Rating) %>%
  summarise(
    mean_installs = mean(Installs, na.rm = TRUE),
    median_installs = median(Installs, na.rm = TRUE),
    total_installs = sum(Installs, na.rm = TRUE),
    n_apps = n()
  ) %>%
  arrange(desc(mean_installs))

# Visualize distribution of installs by content rating
ggplot(data_updated, aes(x = Content.Rating, y = log10(Installs))) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "Distribution of App Installs by Content Rating",
       x = "Content Rating",
       y = "Log10(Number of Installs)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Distribution of Installations by Update Recency and Content Rating
```{r}
data_analysis <- data_updated %>%
  mutate(
    days_since_update = as.numeric(difftime(max(Last.Updated), Last.Updated, units = "days")),
    update_year = year(Last.Updated),
    update_month = month(Last.Updated)
  )


data_analysis <- data_analysis %>%
  mutate(update_recency = ifelse(days_since_update <= median(days_since_update),
                                "Recent Update", "Old Update"))

recent_vs_old <- data_analysis %>%
  group_by(Content.Rating, update_recency) %>%
  summarise(
    mean_installs = mean(Installs, na.rm = TRUE),
    median_installs = median(Installs, na.rm = TRUE),
    n_apps = n()
  )

print("\nComparison of Installs by Update Recency and Content Rating:")
print(recent_vs_old)


# 7. Visualization of update recency effect
ggplot(data_analysis, aes(x = Content.Rating, y = log10(Installs), fill = update_recency)) +
  geom_boxplot() +
  labs(title = "Install Distribution by Content Rating and Update Recency",
       x = "Content Rating",
       y = "Log10(Number of Installs)",
       fill = "Update Recency") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
The boxplot shows the distribution of app installs across different content ratings, segmented by update recency (old vs. recent). Apps with recent updates generally have higher median installs compared to those with older updates, indicating that more frequently updated apps tend to attract more users. This trend is evident across most content ratings, especially for categories like "everyone" and "teen," where recent updates show a noticeable increase in the upper range of installs. For "everyone 10+" and "mature 17+," the difference between old and recent updates is less pronounced, suggesting that the effect of update recency on installs might be weaker in these categories. The "adults only 18+" and "unrated" categories still exhibit lower install numbers overall, regardless of update recency, highlighting the limited popularity of these app types.


#### Visualization for Last Updated vs Content Rating vs Installs 

```{r}
# 3. Timeline analysis: Average installs over time by content rating
installs_timeline <- data_updated %>%
  group_by(Content.Rating, Last.Updated) %>%
  summarise(avg_installs = mean(Installs, na.rm = TRUE)) %>%
  ungroup()

ggplot(installs_timeline, aes(x = Last.Updated, y = log10(avg_installs), color = Content.Rating)) +
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "Average App Installs Over Time by Content Rating",
       x = "Last Updated Date",
       y = "Log10(Average Installs)") +
  theme_minimal() +
  theme(legend.position = "bottom")
```
The line graph depicts the trend of average app installs over time for different content ratings, with the y-axis on a logarithmic scale (`log10`). The curves reveal that apps with broader content ratings like "everyone" and "everyone 10+" show significant growth in average installs, particularly from 2016 onwards, reaching a peak around 2018. This indicates a surge in popularity and possibly greater user engagement or app availability during that period. Similarly, "mature 17+" apps follow a parallel trend but start with higher average installs and decline around 2012 before recovering alongside the other categories. 

The "teen" content rating exhibits a unique pattern with fluctuating growth, maintaining relatively steady installs before rising sharply from 2016 onwards. In contrast, "adults only 18+" shows a limited increase, suggesting that apps with this rating have a smaller user base. The convergence of all content ratings towards higher install averages near 2018 reflects an overall trend in the app market where app downloads increased across various content ratings.


# Correlation 

#### Correlation for all variables in data_final
Lets convert all the categorical variables into factors and then convert into numerical dataframe for calucalting the correlation matrix 
```{r}

# Step 1: Create a copy of the original data without specific columns
columns_to_remove <- c("App", "Scaled_Reviews", "update_year", "update_month", 
                      "update_quarter", "days_since_update", "week_of_year", 
                      "Last.Updated", "day_of_week", "month_of_year", "season")
data_numeric_or_factor <- data_updated %>%
  select(-any_of(columns_to_remove))  # Changed to any_of to handle missing columns gracefully

# Step 2: Identify and convert character columns to factors
data_numeric_or_factor <- data_numeric_or_factor %>%
  mutate(across(where(is.character), as.factor))

# Step 3: Create a copy for factor data
data_factor <- data_numeric_or_factor

# Step 4: Identify numeric and factor columns
numeric_columns <- sapply(data_numeric_or_factor, is.numeric)
factor_columns <- sapply(data_numeric_or_factor, is.factor)

# Step 5: Convert factors to numeric while preserving numeric columns
data_final_numeric <- data_numeric_or_factor %>%
  mutate(across(where(is.factor), ~as.numeric(as.factor(.))))

# Step 6: Check for any non-numeric columns and remove them
non_numeric_cols <- names(data_final_numeric)[!sapply(data_final_numeric, is.numeric)]
if(length(non_numeric_cols) > 0) {
  data_final_numeric <- data_final_numeric %>%
    select(-all_of(non_numeric_cols))
}

# Step 7: Calculate correlations
# Pearson correlation
pearson_correlation <- cor(data_final_numeric, 
                         method = "pearson", 
                         use = "complete.obs")

# Spearman correlation
spearman_correlation <- cor(data_final_numeric, 
                          method = "spearman", 
                          use = "complete.obs")



# Step 9: Create enhanced correlation plots
# Pearson correlation plot

corrplot(pearson_correlation,
         method = "color",
         type = "upper",
         order = "hclust",
         addCoef.col = "black",
         tl.col = "black",
         tl.srt = 45,
         number.cex = 0.7,
         title = "Pearson Correlation Matrix")
        

# Spearman correlation plot
corrplot(spearman_correlation,
         method = "color",
         type = "upper",
         order = "hclust",
         addCoef.col = "black",
         tl.col = "black",
         tl.srt = 45,
         number.cex = 0.7,
         title = "Spearman Correlation Matrix")
```
From the above correlation matrix:

* As seen installs has the highest correlation with the reviews.

* As we can see from the both pearson and spearman have relatively different correlation matrices and plots. We can refer to the categorical variables correlation from the spearman.

* As seen reviews has the highest correlation(positive) with the installs and then in spearman correlation matrix it has high correlation(positive) with content rating and android version meaning

* Rating is not much correlated with any of the variables, only slightly positively correlated with reviews and installs which was also demonstrated through visualisation previously.

* Price vs. Log_Installs: -0.06, suggesting a very weak negative
relationship between price and the number of installs.


#### Correlation between time analysis variables VS Installs

```{r}

# Create a new data frame with relevant variables for correlation analysis
correlation_data <- data_analysis %>%
  select(days_since_update, update_year, update_month) %>%
  mutate(log_installs = log10(data_final$Installs))

# Calculate the correlation matrix
correlation_matrix <- cor(correlation_data, method = "spearman", use = "complete.obs")

# Print the correlation matrix
print("Spearman Correlation Matrix:")
corrplot(correlation_matrix, method = "color",
          col = colorRampPalette(c("red", "white", "blue"))(200),
          type = "upper",
          tl.col = "black", tl.srt = 45,
          addCoef.col = "black", # Add correlation coefficients
          number.cex = 0.7,      # Adjust size of numbers
          title = "Correlation Matrix", # Title
          mar = c(0, 0, 1, 0))   # Margins

```

Correlation Analysis:
A moderate negative correlation :(ρ=−0.3317) was found between the number of days since the last update and the log-transformed installs. This indicates that as the time since the last update increases, the number of installs tends to decrease. The relationship is statistically significant (p < 2.2e-16), suggesting that timely updates may be crucial for maintaining user engagement.

```{r}
# Calculate Pearson correlation and perform the test
cor_test <- cor.test(data_clean$Size, data_clean$Installs, method = "pearson")

# Output the correlation coefficient and p-value
cor_test
```
According to the relational hypothesis testing:
1. Correlation Coefficient (cor):Pearson correlation coefficient is 0.0407. This indicates a very weak positive relationship between Size and Installs—meaning that as app size increases, installs slightly tend to increase as well, but the effect is minimal.

P-value): The p-value is 6.198e-05 (or 0.00006198), which is much smaller than the conventional significance level (e.g., 0.05). This low p-value means that we can reject the null hypothesis (that there is no correlation) and conclude that x and y are not independent.

Confidence Interval: The 95% confidence interval for the correlation coefficient is between 0.0208 and 0.0606. This range is quite narrow and close to zero, further confirming that while the relationship is significant, the strength of the correlation is very low.


```{r}

# Convert "Last Updated" to Date format and calculate days since a reference date
data_updated$Last.Updated <- as.Date(data_updated$Last.Updated, format = "%B %d, %Y")
reference_date <- as.Date("2024-01-01")
data_updated$Days.Since.Last.Update <- as.numeric(difftime(reference_date, data_updated$Last.Updated, units = "days"))

# Clean "Installs" to remove "+" and "," characters and convert to numeric
data_updated$Installs <- as.numeric(gsub("[+,]", "", data_updated$Installs))

# Ensure "Reviews" is numeric
data_updated$Reviews <- as.numeric(data_updated$Reviews)

# Encode "Content Rating" as a factor and then to numeric
data_updated$Content.Rating.Encoded <- as.numeric(as.factor(data_updated$Content.Rating))

# Select relevant columns for correlation calculation
correlation_data <- data_updated %>% 
  select(Days.Since.Last.Update, Content.Rating.Encoded, Rating, Reviews, Installs)

# Calculate correlations for specific columns
selected_correlations <- cor(correlation_data, use = "complete.obs")[c("Days.Since.Last.Update", "Content.Rating.Encoded"), c("Rating", "Reviews", "Installs")]

# Print the selected correlations
print(selected_correlations)

```

Implications
These findings suggest that regular updates are important for sustaining app installs, and that different content ratings can influence user engagement. Strategies aimed at timely updates and optimizing content ratings could enhance app performance and user acquisition.

# Statistical Tests

#### Statistical test for Installs and Price 

```{r}
# Check for missing values and ensure no negative/zero values in log_Installs
#data_final <- data_final %>%
  #filter(!is.na(Installs), Installs > 0)  # Remove missing values and zeros in Installs

# Apply log transformation, adding 1 to avoid log(0)
#data_final$log_Installs <- log(data_final$Installs + 1)

# Ensure Price_Category has no missing values
#data_final <- data_final %>%
 #filter(!is.na(Price_Category))

#Perform t-test on log-transformed Installs by Price Category
#t_test_result <- t.test(log_Installs ~ Price_Category, data = data_final, var.equal = FALSE)

#Print t-test results
#print(t_test_result)

```

There is a statistically significant difference between the number of
installs for "Free" and "Paid" apps, with the p-value being extremely
small.

From the above analysis, we can practically state that free apps are
more popular than paid apps, which can be considered true in the app
market.


#### T-Test for Reviews and Price 
```{r}
#Confirming with a t-test
# Perform t-test for Reviews between Free and Paid
t_test_reviews <- t.test(Reviews ~ Price_Category, data = data_updated)

# Perform t-test for Rating between Free and Paid
t_test_rating <- t.test(Rating ~ Price_Category, data = data_updated)

# Print the results
print(t_test_reviews)
print(t_test_rating)


```
* There is a statistically significant difference between the mean number of reviews for Free and Paid apps. Free apps have significantly more reviews on average.

* There is a statistically significant difference between the mean ratings for Free and Paid apps. Paid apps have slightly higher ratings on average, though the difference is small.


#### ANOVA Test for Reviews vs Ratings

The tests below are to test whether or not different review categories have
different average ratings.

```{r}
anova_result <- aov(Rating ~ as.factor(Review_Category), data = data_clean)
summary(anova_result)
```

According to p-value, it is significant hence we can say that the average rating for all review categories is not same.

#### Post Hoc Test

```{r}
# Perform Tukey's HSD
tukey_result <- TukeyHSD(anova_result)
tukey_result
# Convert the result to a data frame
tukey_df <- as.data.frame(tukey_result$`as.factor(Review_Category)`)

# Filter for significant p-values
significant_tukey <- tukey_df[tukey_df[4] < 0.05, ]

# Display the significant results
print(significant_tukey)


```

As we can see, the significant difference for average rating for
different review categories is between 0+ and 1M+ as expected.

For easier Ratings and Reviews vs Installs we can group Installs into
categories given

#### ANOVA test for Content Rating vs Installs 

```{r}
# 1. Encode content rating (e.g., as factor levels or one-hot encoding)
data_updated$Content.Rating <- as.factor(data_updated$Content.Rating)

data_updated <- data_updated %>%
  filter(!is.na(Installs) & Installs > 0)

# ANOVA test for difference in installs between content ratings
install_anova <- aov(log10(Installs) ~ Content.Rating, data = data_updated)

print("\nANOVA test results for Installs by Content Rating:")
print(summary(install_anova))


```


ANOVA analysis : 
Revealed significant differences in install counts based on content rating (F(5, 9638) = 41.95, p < 2e-16). This indicates that various content ratings have a substantial impact on the number of installs, highlighting the importance of content quality and type in attracting users.


# Data Preprocessing for Modelling

```{r}
# Convert the 'last_updated' column to Date type
data_updated$last_updated <- as.Date(data_updated$last_updated, format = "%B %d, %Y")

# Calculate the difference in days between the maximum date and each date in 'last_updated'
data_updated$lastupdate <- as.numeric(difftime(max(data_updated$last_updated, na.rm = TRUE), 
                                       data_updated$last_updated, 
                                       units = "days"))


data_updated$last_updated <- NULL

```

#### Last updated

```{r}
data_updated <- data_updated[, !(names(data_updated) %in% c(
  "Last.Updated", "Android.Ver", "last_updated", "current_date", 
  "days_since_update", "update_month", "season", 
  "Days.Since.Last.Update", "Content.Rating.Encoded","App"))]

# Rename a column
names(data_updated)[names(data_updated) == "Content.Rating"] <- "content_rating"
data_updated$content_rating <- as.numeric(data_updated$content_rating)

str(data_updated)


```

#### Category

```{r}
category_dummies <- model.matrix(~ Category - 1, data = data_updated)
colnames(category_dummies) <- gsub("Category", "cat", colnames(category_dummies))

# 3. Add dummy variables to the dataset and remove the original 'Category' column
data_updated <- cbind(data_updated, category_dummies)
data_updated$Category <- NULL

# 4. Replace spaces in column names with underscores
colnames(data_updated) <- gsub(" ", "_", colnames(data_updated))

# View the processed data
head(data_updated)

```  

#### Installs

```{r}

# Load necessary libraries
library(ggplot2)

# Create two categories: Low Installs and High Installs
# Calculate the median of Installs to split into two categories
median_installs <- median(data_updated$Installs, na.rm = TRUE)


# Reclassify into two categories
data_updated$Installs_Category <- ifelse(data_updated$Installs <= median_installs, "Low Installs", "High Installs")


# Convert 'Installs_Category' to factor with levels "Low Installs" and "High Installs"
data_updated$Installs_Category <- factor(data_updated$Installs_Category, 
                                         levels = c("Low Installs", "High Installs"), 
                                         labels = c(0, 1))

# Check the conversion
table(data_updated$Installs_Category)

# Create a histogram for the new categories
ggplot(data_updated, aes(x = Installs_Category)) +
  geom_bar(stat = "count", fill = "skyblue", color = "black") +
  labs(title = "Histogram of Installs Category (Low vs High)",
       x = "Installs Category",
       y = "Count") +
  theme_minimal()



```

```{r}
str(data_updated)
```

```{r}
# Boxplot for the same
ggplot(data_updated, aes(y=Installs)) +
  geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 1, fill="pink", color="black") +
  labs(title="Installs Boxplot", y="Installs") +
  theme_minimal()
```
So, now our final dataset after preprocessing is named as 'data_updated'. We have selected five modelling techniques that would be best suitable for answering our SMART Question.

# Data Modelling

## Logistic Regression
```{r}

```


## KNN
```{r}

```
#------------------------------------------------------------------------- 


## Decision Tree

#### Splitting the data into train and test split

```{r}
# Remove the Installs and Installs numerical columns
data <- data_updated[, !colnames(data_updated) %in% c("Installs")]

# Split the data into training and testing sets
set.seed(123)  # Ensure reproducibility
trainIndex <- createDataPartition(data$Installs_Category, p = 0.8, list = FALSE)
trainData <- data[trainIndex, ]
testData <- data[-trainIndex, ]
```

```{r}
# Load necessary libraries
library(rpart)
library(rpart.plot)

# Fit the decision tree model
set.seed(42)
tree_model <- rpart(
  Installs_Category ~ . ,
  data = trainData,
  method = "class"
)

# Plot the decision tree
rpart.plot(tree_model, main = "Decision Tree for Predicting Installs Category")

```

```{r}
# Predict on training and test datasets
train_predictions <- predict(tree_model, trainData, type = "class")
test_predictions <- predict(tree_model, testData, type = "class")

# Calculate accuracy
train_accuracy <- sum(train_predictions == trainData$Installs_Category) / nrow(trainData)
test_accuracy <- sum(test_predictions == testData$Installs_Category) / nrow(testData)

# Print accuracy results
cat("Training Accuracy: ", train_accuracy, "\n")
cat("Test Accuracy: ", test_accuracy, "\n")


```

**Why shift to Random Forest?**
High Dimensionality: With 41 variables, random forest handles many features better and can identify the most important ones.<br>
Feature Importance: Random forest provides a ranking of feature importance, helping us understand which variables influence the Installs_Category.<br>
Accuracy: Random forest generally has better predictive accuracy for larger and more complex datasets.<br>

## Random Forest

In this analysis, we employ a Random Forest model to predict the number of installs based on the top 5 app categories. The Random Forest algorithm is a robust ensemble learning method that builds multiple decision trees and combines their predictions to improve accuracy and reduce overfitting. 

#### Building Random Forest Classifier

```{r}
library(randomForest)
library(caret)

# Train the random forest model
set.seed(123)
rf_model <- randomForest(Installs_Category ~ ., 
                         data = trainData, 
                         ntree = 500,       # Number of trees
                         mtry = 4,  # Number of predictors sampled at each split
                         importance = TRUE) # Enable importance calculation

# Print the model summary
print(rf_model)
```

#### Plotting the Random Forest Result

```{r}
# Plot the Random Forest model
plot(rf_model, main = "Random Forest Model Performance")

# Add a legend to explain the colors
legend("topright",                              
       legend = c("OOB Error", "Class 1 Error", "Class 2 Error"), 
       col = c("black", "red", "green"),       
       lty = 1,                                
       cex = 0.8)                             

```
* This plot depicts the Out-of-Bag (OOB) error and class-specific errors for a Random Forest model as the number of trees increases.<br>
* Model Stability: The OOB error stabilizing at a low value suggests that the Random Forest model is well-trained and not overfitting.<br>
* Class Imbalance or Complexity: The higher error for Class 2 compared to Class 1 could imply class imbalance or that Class 2 is inherently harder to classify (e.g., due to overlapping features with Class 1).


#### Testing the accuracy 

```{r}
# Predictions on the training set
train_predictions <- predict(rf_model, trainData)

# Predictions on the testing set
test_predictions <- predict(rf_model, testData)

# Confusion Matrix for Training Data
train_cm <- confusionMatrix(train_predictions, trainData$Installs_Category)
print(train_cm)

# Confusion Matrix for Testing Data
test_cm <- confusionMatrix(test_predictions, testData$Installs_Category)
print(test_cm)

```

#### PLotting the Training, Testing and error Rate

```{r}
# Initialize vectors to store results
training_accuracy <- numeric(500)
testing_accuracy <- numeric(500)
oob_error <- rf_model$err.rate[, 1] # OOB error directly from the model

# Calculate accuracies for training and testing sets at each tree
for (i in 1:500) {
  # Subset Random Forest model up to 'i' trees
  partial_model <- randomForest(Installs_Category ~ ., 
                                data = trainData, 
                                ntree = i, 
                                mtry = 10, 
                                importance = FALSE)

  # Training accuracy
  train_preds <- predict(partial_model, trainData)
  training_accuracy[i] <- mean(train_preds == trainData$Installs_Category)

  # Testing accuracy
  test_preds <- predict(partial_model, testData)
  testing_accuracy[i] <- mean(test_preds == testData$Installs_Category)
}

# Plotting the results
plot(1:500, oob_error, type = "l", col = "black", lwd = 2,
     ylim = c(0, 1), xlab = "Number of Trees", ylab = "Error / Accuracy",
     main = "Random Forest Model Performance")
lines(1:500, training_accuracy, col = "blue", lwd = 2)
lines(1:500, testing_accuracy, col = "red", lwd = 2)
legend("topright", legend = c("OOB Error", "Training Accuracy", "Testing Accuracy"),
       col = c("black", "blue", "red"), lty = 1, lwd = 2)

```

```{r}
# Performance on Training Data
train_predictions <- predict(rf_model, newdata = trainData)
train_conf_matrix <- table(train_predictions, trainData$Installs_Category)
train_accuracy <- sum(diag(train_conf_matrix)) / sum(train_conf_matrix)
cat("Training Accuracy: ", train_accuracy, "\n")

# Performance on Testing Data
test_predictions <- predict(rf_model, newdata = testData)
test_conf_matrix <- table(test_predictions, testData$Installs_Category)
test_accuracy <- sum(diag(test_conf_matrix)) / sum(test_conf_matrix)
cat("Testing Accuracy: ", test_accuracy, "\n")

# OOB Error from the model
oob_error <- rf_model$err.rate[500, "OOB"]
oob_accuracy <- 1 - oob_error
cat("OOB Accuracy: ", oob_accuracy, "\n")

# Compare Results
comparison <- data.frame(
  Dataset = c("Training", "Testing", "OOB"),
  Accuracy = c(train_accuracy, test_accuracy, oob_accuracy)
)
print(comparison)

```

```{r}
# Install and load pROC package if not already installed
if (!require("pROC")) install.packages("pROC", dependencies = TRUE)
library(pROC)

# Get predicted probabilities for the positive class (class '1')
rf_prob <- predict(rf_model, testData, type = "prob")[, 2] # Probabilities for class '1'

# Compute ROC curve and AUC
roc_curve <- roc(testData$Installs_Category, rf_prob)

# Plot the ROC curve
plot(roc_curve, col = "blue", lwd = 2, main = "ROC Curve for Random Forest")
abline(a = 0, b = 1, lty = 2, col = "gray") # Diagonal reference line

# Display the AUC value
auc_value <- auc(roc_curve)
cat("AUC:", auc_value, "\n")

```

#### Feature Importance Values

```{r}
# Variable importance
importance(rf_model)

# Plot variable importance
varImpPlot(rf_model)
```

#### Visualization for Feature Importance


```{r}
# Extract importance values
importance_values <- importance(rf_model)
importance_df <- data.frame(
  Feature = rownames(importance_values),
  MeanDecreaseAccuracy = importance_values[, "MeanDecreaseAccuracy"],
  MeanDecreaseGini = importance_values[, "MeanDecreaseGini"]
)

```

```{r}
# Plot Mean Decrease in Accuracy
accuracy_plot <- ggplot(importance_df, aes(x = reorder(Feature, MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  coord_flip() +
  labs(
    title = "Feature Importance (Mean Decrease in Accuracy)",
    x = "Features",
    y = "Importance"
  ) +
  theme_minimal() +
  theme(text = element_text(size = 12), axis.text.y = element_text(size = 10))

# Plot the accuracy plot
print(accuracy_plot)

# Save the plot with larger dimensions
#ggsave("feature_importance_accuracy_large.png", plot = accuracy_plot, width = 12, height = 10, dpi = 300)

# Plot Mean Decrease in Gini
gini_plot <- ggplot(importance_df, aes(x = reorder(Feature, MeanDecreaseGini), y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", fill = "lightgreen") +
  coord_flip() +
  labs(
    title = "Feature Importance (Mean Decrease in Gini)",
    x = "Features",
    y = "Importance"
  ) +
  theme_minimal() +
  theme(text = element_text(size = 12), axis.text.y = element_text(size = 10))

# Plot the gini index plot
print(gini_plot)

# Save the plot with larger dimensions
#ggsave("feature_importance_gini_large.png", plot = gini_plot, width = 12, height = 10, dpi = 300)


```



## Gradient Boosting


```{r}

# 2. Feature Engineering ------------------------------------------------

# Create binary target variable: High success (Installs >= median) vs. Low success
median_installs <- median(data_updated$Installs, na.rm = TRUE)
data_updated$Success <- ifelse(data_updated$Installs >= median_installs, 1, 0)

# Convert 'Category' to dummy variables (one-hot encoding)
# data_updated <- data_updated %>%
#   mutate(Category = as.factor(Category)) %>%
#   cbind(model.matrix(~ Category - 1, data_updated))


# Drop unused columns
#data_updated <- data_updated %>% select(-Android.Ver, -Content.Rating, -Last.Updated)

```


```{r}
# 3. Data Splitting -----------------------------------------------------

# Separate features (X) and target (y)
#X <- data_final %>% select(-Installs, -Success)
X <- data_updated %>% select(-Installs, -Success)  # Exclude the target variable
y <- data_updated$Success             # Extract the target variable

table(y) 
#Split into training and testing sets
set.seed(123)
train_index <- createDataPartition(y, p = 0.7, list = FALSE)

# Define X_train, X_test, y_train, y_test
X_train <- X[train_index, ] %>% mutate(across(everything(), as.numeric))
X_test <- X[-train_index, ] %>% mutate(across(everything(), as.numeric))
y_train <- y[train_index]
y_test <- y[-train_index]

# Check the structure



```

```{r}

# Convert data to matrix for XGBoost
dtrain <- xgb.DMatrix(data = as.matrix(X_train), label = y_train)
dtest <- xgb.DMatrix(data = as.matrix(X_test), label = y_test)

```


```{r}
# 4. Train Gradient Boosting Model --------------------------------------

params <- list(
  objective = "binary:logistic",  # Binary classification
  eval_metric = "logloss",
  max_depth = 6,
  eta = 0.1,
  subsample = 0.8,
  colsample_bytree = 0.8
)

# Train the model
set.seed(42)
xgb_model <- xgb.train(
  params = params,
  data = dtrain,
  nrounds = 100,
  watchlist = list(train = dtrain, test = dtest),
  early_stopping_rounds = 10,
  verbose = 1
)


```


```{r}
# 5. Model Evaluation ---------------------------------------------------

# Make predictions
y_pred <- predict(xgb_model, dtest)
y_pred_class <- ifelse(y_pred > 0.5, 1, 0)

# Confusion Matrix
y_pred_class <- factor(y_pred_class, levels = c(0, 1))
y_test <- factor(y_test, levels = c(0, 1))
conf_matrix <- confusionMatrix(y_pred_class, y_test)
print(conf_matrix)

```


```{r confusion-matrix-heatmap, echo=FALSE}
#Visulization of confusion matrix
# Code to generate and display the confusion matrix heatmap
cm_table <- as.data.frame(conf_matrix$table)
ggplot(cm_table, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = Freq), color = "white", size = 5) +
  scale_fill_gradient(low = "blue", high = "red") +
  labs(title = "Confusion Matrix", x = "Actual", y = "Predicted") +
  theme_minimal()
```



```{r}
# AUC and ROC Curve
roc_obj <- roc(as.numeric(as.character(y_test)), y_pred)
auc_value <- auc(roc_obj)
cat("AUC:", auc_value, "\n")

# Plot ROC Curve
plot(roc_obj, main = "ROC Curve", col = "blue", lwd = 2)
abline(a = 0, b = 1, lty = 2, col = "red")

```


```{r}
# 6. Feature Importance -------------------------------------------------

importance_matrix <- xgb.importance(feature_names = colnames(X_train), model = xgb_model)
xgb.plot.importance(importance_matrix, top_n = 10, main = "Feature Importance")

# 7. Save Model ---------------------------------------------------------

xgb.save(xgb_model, "xgb_app_success.model")

# Summary
cat("Gradient Boosting achieved an accuracy of", conf_matrix$overall["Accuracy"], 
    "and AUC of", auc_value, "\n")
```


## SVM

```{r}
# Convert target variable to a factor
y <- as.factor(data_updated$Installs_Category)

# Remove unused columns
X <- data_updated[, !names(data_updated) %in% c('Installs', 'Installs_Category', 'Installs_Num')]

# Split data into training and testing sets
set.seed(42)
trainIndex <- createDataPartition(y, p = 0.75, list = FALSE)
X_train <- X[trainIndex, ]
X_test <- X[-trainIndex, ]
y_train <- y[trainIndex]
y_test <- y[-trainIndex]

```



### Checking if the boundary is non-linear or linear
```{r}
library(plotly)

# Prepare the plot data
plot_data <- data.frame(X_train, Class = as.factor(y_train))

# Create 3D scatter plot for features 1, 2, and 3
plot_1_2_3 <- plot_ly(data = plot_data, 
                      x = ~X_train[, 1], 
                      y = ~X_train[, 2], 
                      z = ~X_train[, 3], 
                      color = ~Class,
                      colors = c("red", "blue"),  # Set colors for classes (0 and 1)
                      type = 'scatter3d', 
                      mode = 'markers') %>%
  layout(title = "3D Scatter Plot: Feature 1 vs Feature 2 vs Feature 3",
         scene = list(xaxis = list(title = colnames(X_train)[1]),
                      yaxis = list(title = colnames(X_train)[2]),
                      zaxis = list(title = colnames(X_train)[3])))

# Create 3D scatter plot for features 4, 5, and 6
plot_4_5_6 <- plot_ly(data = plot_data, 
                      x = ~X_train[, 4], 
                      y = ~X_train[, 5], 
                      z = ~X_train[, 6], 
                      color = ~Class,
                      colors = c("red", "blue"),  # Set colors for classes (0 and 1)
                      type = 'scatter3d', 
                      mode = 'markers') %>%
  layout(title = "3D Scatter Plot: Feature 4 vs Feature 5 vs Feature 6",
         scene = list(xaxis = list(title = colnames(X_train)[4]),
                      yaxis = list(title = colnames(X_train)[5]),
                      zaxis = list(title = colnames(X_train)[6])))

# Show plots
plot_1_2_3
plot_4_5_6
```


As we can see we cannot decide if the boundary is linear or non-linear hence, lets make two models linear and non-linear SVM to check which one is a better fit.




### Tuning to find the best parameter values for C and Gamma for SVM non-linear

```{r}


# Load necessary libraries
library(e1071)
library(caret)

# Assuming you have already defined X_train, y_train, X_test, y_test

# Combine the training data into a data frame
train_data <- as.data.frame(cbind(X_train, y_train))

# Set up k-fold cross-validation
set.seed(42)
train_control <- trainControl(method = "cv", number = 5)

# Define the tuning grid for 'C' and 'sigma' (gamma)
tune_grid <- expand.grid(C = c( 0.1, 1, 10, 100),
                          sigma = c(0.5, 1))

# Train the SVM model using radial kernel with the tuning grid
svm_model <- train(y_train ~ ., data = train_data,
                   method = "svmRadial",
                   tuneGrid = tune_grid,
                   trControl = train_control,scaled = TRUE)

# Print the results of the tuning
print(svm_model)

# Best model parameters
best_params <- svm_model$bestTune
cat("Best Parameters:\n")
print(best_params)
```

As seen for the training set the best accuracy is achieved when C = 100 and gamma is 0.05

### Tuning to find the best parameter values for C  for SVM linear

```{r}


# Load necessary libraries
library(e1071)
library(caret)

# Assuming you have already defined X_train, y_train, X_test, y_test

# Combine the training data into a data frame
train_data <- as.data.frame(cbind(X_train, y_train))

# Set up k-fold cross-validation
set.seed(42)
train_control <- trainControl(method = "cv", number = 5)

# Define the tuning grid for 'C' and 'sigma' (gamma)
tune_grid <- expand.grid(C = c( 0.1, 1, 10, 100))

# Train the SVM model using radial kernel with the tuning grid
svm_model <- train(y_train ~ ., data = train_data,
                   method = "svmLinear",
                   tuneGrid = tune_grid,
                   trControl = train_control,scaled = TRUE)

# Print the results of the tuning
print(svm_model)

# Best model parameters
best_params <- svm_model$bestTune
cat("Best Parameters:\n")
print(best_params)
```

For linear model it could be seen that at C = 100, we attain an accuracy of 92 percent which suggets that the model is linearly seperable. Hence, now lets find the accuracy, ROC, AUC score of the test data.

#### Bias variance MSE caluclation

```{r}
# Load necessary libraries
library(e1071)
library(ggplot2)
library(reshape2)

# Assuming you have already defined X_train, y_train, X_test, y_test

# Combine training and test sets into data frames
train_data <- as.data.frame(cbind(X_train, y_train))
test_data <- as.data.frame(X_test)

# Initialize vectors to store metrics
C_values <- c(0.1, 1, 10, 100, 1000, 100000, 500000)
bias_values <- c()
variance_values <- c()
mse_values <- c()

# Loop through different values of C
for (C in C_values) {
  # Train the SVM model
  svm_model <- svm(y_train ~ ., data = train_data, kernel = "linear", cost = C, scale = TRUE)
  
  # Predict on the test set
  predictions <- predict(svm_model, newdata = test_data)
  
  # Convert predictions and actual test values to numeric for calculations
  predictions_numeric <- as.numeric(as.character(predictions))
  y_test_numeric <- as.numeric(as.character(y_test))
  
  # Calculate Bias: Mean squared difference between the true mean and the predicted mean
  mean_true <- mean(y_test_numeric)
  mean_pred <- mean(predictions_numeric)
  bias <- (mean_true - mean_pred)^2
  bias_values <- c(bias_values, bias)
  
  # Calculate Variance: Variability of the predictions
  variance <- var(predictions_numeric)
  variance_values <- c(variance_values, variance)
  
  # Calculate Mean Squared Error (MSE): Average squared error
  mse <- mean((y_test_numeric - predictions_numeric)^2)
  mse_values <- c(mse_values, mse)
}

# Combine results into a data frame for plotting
results <- data.frame(
  C = C_values,
  Bias = bias_values,
  Variance = variance_values,
  MSE = mse_values
)

# Reshape data for ggplot
results_melted <- melt(results, id.vars = "C", variable.name = "Metric", value.name = "Value")

# Plotting
ggplot(results_melted, aes(x = factor(C), y = Value, color = Metric, group = Metric)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  labs(title = "Bias-Variance Tradeoff and MSE for Different C Values",
       x = "C Values",
       y = "Value",
       color = "Metric") +
  theme_minimal(base_size = 15) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "top"
  ) +
  scale_color_manual(values = c("Bias" = "blue", "Variance" = "red", "MSE" = "green")) +
  scale_x_discrete(labels = function(x) paste0("C = ", x)) +
  geom_text(aes(label = round(Value, 2)), vjust = -0.5)  # Add value labels above points


```
The analysis of bias, variance, and mean squared error (MSE) across different values of C shows:
MSE Stability: From C = 100 to C = 1000, the MSE remains nearly constant.
Low Bias and Variance: Both metrics are minimized in this range, indicating good generalization without overfitting.
 
Hence, better to select C = 100 for the SVM model to achieve an optimal balance between bias, variance, and MSE.


#### Model Evalution for Test Data

```{r}
# Load necessary libraries
library(e1071)
library(pROC)  # For ROC and AUC

# Assuming you have already defined X_train, y_train, X_test, y_test

# Combine the training data into a data frame
train_data <- as.data.frame(cbind(X_train, y_train))

# Fit the SVM model with linear kernel
svm_model <- svm(y_train ~ ., data = train_data, kernel = "linear", cost = 100, decision.values = TRUE,scaled = TRUE)

# Step 1: Make predictions on the test set
predictions <- predict(svm_model, newdata = as.data.frame(X_test))

# Step 2: Create confusion matrix
confusion_matrix <- table(Predicted = predictions, Actual = y_test)
cat("Confusion Matrix:\n")
print(confusion_matrix)

confusion_matrix_caret <- confusionMatrix(confusion_matrix)

# Step 2: Extract Precision, Recall, and F1 Score
precision <- confusion_matrix_caret$byClass['Precision']
recall <- confusion_matrix_caret$byClass['Recall']
f1_score <- confusion_matrix_caret$byClass['F1']

# Display the metrics
cat("Precision:", precision, "\n")
cat("Recall:", recall, "\n")
cat("F1 Score:", f1_score, "\n")
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
cat("Accuracy:", accuracy, "\n")

# Step 4: Get decision values for ROC curve
fitted <- attributes(predict(svm_model, newdata = as.data.frame(X_test), decision.values = TRUE))$decision.values

# Step 5: Generate ROC plot for the test set
roc_curve <- roc(y_test, -fitted)  # Note: Use negative for class labeling

# Plot the ROC curve
plot(roc_curve, main = "ROC Curve for Test Data")
# Add AUC to the plot
auc_value <- auc(roc_curve)
legend("bottomright", legend = paste("AUC =", round(auc_value, 2)), bty = "n")




```

The model achieved an impressive accuracy of 94% and a high AUC of 0.99, indicating excellent performance in classification. Additionally, the high precision, recall, and F1-score values reflect the model's capability to accurately classify both class 0 and class 1. These results suggest that the model is highly effective in distinguishing between the two classes, making it reliable for practical applications.



#### Feature importance for the model

```{r}
# Assuming you have already trained your SVM model (svm_model) using e1071

# Get coefficients from the SVM model
coefficients <- as.vector(svm_model$coefs) %*% svm_model$SV

# Get the intercept term
intercept <- svm_model$rho

# Combine coefficients and intercept into a single vector
all_coefficients <- c(intercept, coefficients)

# Print coefficients
cat("Coefficients (including intercept):\n")
print(all_coefficients)

# Check the number of coefficients
num_coefficients <- length(all_coefficients)
cat("Number of Coefficients (including intercept):", num_coefficients, "\n")

# Get feature names
feature_names <- colnames(X_train)

# Create a named vector for coefficients with feature names
named_coefficients <- setNames(coefficients, feature_names)

# Print named coefficients
cat("Feature Coefficients:\n")
print(named_coefficients)

# Sort coefficients by absolute value for feature importance
sorted_coefficients <- sort(abs(named_coefficients), decreasing = TRUE)

# Print sorted feature importance
cat("Sorted Feature Importance:\n")
print(sorted_coefficients)
top_coef = head(sorted_coefficients,15)
# Optional: Visualize feature importance
barplot(
  top_coef,
  main = "Feature Importance from SVM Coefficients",
  xlab = "Features",
  col = "steelblue",
  las = 2,
  cex.names = 0.3,# Adjust name size if necessary
  horiz = TRUE
)


```

The analysis shows that Reviews, Price, and Size are the top features influencing the model's performance. Additionally, the leading app categories—Photography, Medical, Family, Personalization, and Health and Fitness—suggest that focusing on these areas can enhance the chances of app success.


